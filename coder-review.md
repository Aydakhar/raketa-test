## AddToCartController
- endpoint должен быть post, т.к. действие добавления
- если корзину не получаем, создадим новую, т.к. она просто может еще не быть инициализированной
- обернем в try/catch, при исключении вернем ошибку и 500
- статус 201 при создании item'а для корзины

## GetCartController
- тут не уверен, как правильнее - создавать новую корзину или возвращать ошибку, если getCart корзину не вернул
- ставим статус error при возвращении ошибки, success и код 200 - при успешном возвращении результата

## GetProductsController
- внедрим зависимость ProductRepository
- для начала надо получить продукты категории через ProductRepository, затем каждый продукт конвертировать в массив
- также обернем в try/catch, при исключении вернем ошибку и 500
- но думаю, что эффективнее было бы определить отдельный метод в ProductRepository, который возвращает сразу ассоциативный массив

## Cart
- нужно учесть добавление продукта, уже существующего в корзине, в таком случае необходимо
  просто добавить quantity соответствующему cart item

## CartItem
- избавимся от readonly, чтобы реализовать написанное выше

## Connector
- исправим тип параметра в get() на корректный

## CartManager
- $this->connector->set(session_id(), $cart) - правильный порядок аргументов
- в getCart() проверяем, есть ли сохраненное значение, прежде чем его доставать
- в logger прокидываем более полезное для логов сообщение исключения
- возможно, при исключении стоит возвращать null?

## ProductRepository
- getByCategory() - нужна выборка всех полей в sql запросе
- также замыкание нужно нестатическое, чтобы произошла привязка $this

## CartView
- лучше извлечь $customer один раз вместо нескольких, особенно если в будущем эти геттеры усложнятся

## ProductView
- toArray() должен принимать объект продукта и возвращать ассоциативный массив, 
получение продукта по категории можно оставить клиентскому коду
- не забыть вернуть имя продукта
